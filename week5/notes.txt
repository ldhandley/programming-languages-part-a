Video 1 - What is Type Inference
* Static type checking = type checking at compile time
* Static type checking can reject a program before it runs to prevent the possibility of some errors
* At compile time, variables in statically typed languages are given 1 type at compile time. 
* Other statically typed langs besides ML: Java, C, C++, C#, Scala
* Dynamically typed languages do not do type checking at compile time, so you can accidentally 
* ML is also implicitly typed: you don't have to write down the types usually. This sometimes makes people forget that it's statically typed (types are checked at runtime.)
* For example, ML would check to make sure types of the then and else branches of an if statement match
* Type inference problem: gives every binding/expression a type such that type-checking succeeds. Fail if and only if no solution for giving types to everything exists.

Video 2 - ML Type Inference
* Goal of these lectures is to be able to do type inference in your head. We'll go thru lots of examples 
* There is a precise process that ML goes through, but we won't really learn this.
* Key Steps:
  * ML determines the types of bindings in order. This is why you have to put the definition of a helper function before you call it. Otherwise, it won't have checked the type of the helper yet. 
  * For each val or fun bindng:
    * Analyze definition for all necessary constraints (facts)
    * If x>0, then x must have type int (the > operator only works on ints)
    * If there's no way for all facts to hold up (over-constrained), type error!
  * For variables that are unconstrained, use type variables ('a) - for example, an unused argument can have any type. It doesn't matter what type you stick in there since it's never used. 
  * Finally, enforce value restriction, which we will discuss later 
* Polymorphism (type variables, a') & type inference are completely separate concepts and languages can pick and choose both, one or the other, or neither. 
  * Can have type inference without type variables
  * Can have type variables without type inference

Video: Mutual Recursion
* What if we wanted to allow f to call g and g to call f?
  * PROBLEM! in ML, bindings have to come in order!
* Solution #1: put "and" between function definitions. Everything in the mutual recursion bundle are type-checked together and can refer to each 
  * See state machine example code
* Solution #2: if you pass a function defined later as a parameter into an earlier function, you can still do mutual recursion!
  * fun earlier (f,x) = ... f y ...
    ... (* no need to be next to each other*) ...
    fun later x = ... earlier(later,y)

Video: Modules for Namespace Management
*  
*  
*  
*  
*  
